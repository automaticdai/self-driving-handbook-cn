# 异构计算与车规要求：架构、带宽、功能安全

本页聚焦 CCU 的系统架构与量产关键约束，涵盖异构计算调度、内存优化、功能安全与网络安全。

---

## 1. 异构计算架构

### 1.1 计算链路分工

自动驾驶计算链路通常是多种处理器协同工作：

```
传感器数据输入
    │
    ↓ ISP（图像信号处理器）
相机图像预处理（去噪/去马赛克/HDR/畸变校正）
    │
    ↓ NPU/GPU（并行推理加速）
神经网络推理（BEV感知/目标检测/预测/规划）
    │
    ↓ CPU（串行逻辑控制）
决策逻辑/轨迹选择/异常处理
    │
    ↓ 安全岛 MCU（ASIL-D）
功能安全监控/看门狗/降级触发
    │
    ↓ 执行器接口
底盘 CAN 指令输出
```

### 1.2 任务映射策略

| 任务 | 计算单元 | 原因 |
| --- | --- | --- |
| BEV Backbone（Transformer）| GPU | 矩阵乘法并行度高 |
| 目标检测 Head | NPU/DLA | INT8 推理，功耗低 |
| LiDAR 点云处理 | GPU | 大量并行点运算 |
| 预测模型（GNN/Transformer）| GPU/NPU | 视模型复杂度决定 |
| 规划轨迹优化（QP）| CPU | 求解器串行，算力要求低 |
| 定位融合（EKF/因子图）| CPU + DSP | 高频矩阵运算 |
| 功能安全监控 | 安全岛 MCU | 独立于主计算，ASIL-D |

### 1.3 并发调度框架

```python
# GPU 流水线调度（伪代码）
stream_high = cuda.Stream(priority=HIGH)     # 感知主链路
stream_mid  = cuda.Stream(priority=MEDIUM)   # 预测/辅助感知
stream_low  = cuda.Stream(priority=LOW)      # 后处理/可视化

with stream_high:
    bev_features = backbone(cameras)         # 主链路，高优先级
    objects = detector(bev_features)

with stream_mid:
    trajectory = predictor(object_history)   # 并发执行

# 同步关键路径
cuda.synchronize(stream_high)
control_cmd = planner(objects, trajectory)
```

---

## 2. 内存层次结构

### 2.1 存储器角色

| 存储层次 | 容量 | 带宽 | 访问时延 | 用途 |
| --- | --- | --- | --- | --- |
| 片上 SRAM | 数十 MB | 10+ TB/s | < 1 ns | 权重缓存、激活值暂存 |
| NPU 本地内存 | 数 MB | TB/s 级 | < 5 ns | 推理中间结果 |
| LPDDR5（主内存）| 8–32 GB | 100–250 GB/s | 20–50 ns | 模型权重、帧缓存 |
| eMMC/UFS（存储）| 64–256 GB | 1–4 GB/s | μs 级 | OS、日志、地图 |

### 2.2 带宽压力分析

典型 L4 工作负载的内存带宽需求：

```
8 路相机原始数据（未压缩）：8 × 1.6 GB/s ≈ 12 GB/s
LiDAR 点云传输：~2 GB/s
BEV Transformer 权重读取：~5 GB/s
中间激活值读写：~10–20 GB/s（模型相关）
──────────────────────────────
合计峰值：~30–40 GB/s
```

LPDDR5 理论带宽 ~250 GB/s（双通道），但实际有效带宽受访问模式和并发冲突影响，通常只有 40%–60% 可用。

---

## 3. 数据搬运优化

### 3.1 DMA 引擎

DMA（Direct Memory Access）允许数据在内存和外设之间直接传输，不占用 CPU：

```
CPU 配置 DMA 描述符 → DMA 引擎独立搬运 → 完成后触发中断
    │                         │
    └─ CPU 可以并行处理其他任务  └─ 相机数据写入 NPU 输入 Buffer
```

### 3.2 零拷贝（Zero-Copy）

避免数据在 CPU 和加速器之间的冗余拷贝：

**传统模式（三次拷贝）：**

```
相机 ISP 输出 → CPU Buffer（拷贝1）→ 编码/处理 → GPU Buffer（拷贝2）→ 推理 → CPU 结果（拷贝3）
```

**零拷贝模式（共享物理地址）：**

```
相机 ISP 输出 → 共享内存（物理连续）→ CPU 和 GPU 都可直接访问（无拷贝）
```

实现方式：

- **ION/DMA-BUF**（Linux）：用于 CPU/GPU/NPU 之间的共享内存
- **CUDA Unified Memory**：NVIDIA GPU 与 CPU 的统一内存地址空间
- **IOMMU 保护**：防止 DMA 越界访问其他模块内存

### 3.3 共享内存区域规划

```
物理内存布局示例（32 GB LPDDR5）：

┌─────────────────────────────────────────────────────┐
│ 0x0000_0000 ─ 0x00FF_FFFF（256 MB）: OS/内核        │
├─────────────────────────────────────────────────────┤
│ 0x0100_0000 ─ 0x08FF_FFFF（2 GB）：安全关键区       │
│  感知输出、规划结果（ASIL-B/D 数据，只写控制）       │
├─────────────────────────────────────────────────────┤
│ 0x0900_0000 ─ 0x18FF_FFFF（4 GB）：感知共享区       │
│  相机图像、点云（DMA-BUF 共享，CPU/GPU/NPU）        │
├─────────────────────────────────────────────────────┤
│ 0x1900_0000 ─ 0x78FF_FFFF（16 GB）：模型权重区      │
│  NPU/GPU 只读，模型更新时重新映射                   │
├─────────────────────────────────────────────────────┤
│ 0x7900_0000 ─ 0x7FFF_FFFF（剩余）：日志/调试区      │
└─────────────────────────────────────────────────────┘
```

---

## 4. ISO 26262 功能安全要求

### 4.1 ASIL 分解

复杂系统通常通过 ASIL 分解将高等级需求分配到独立子系统：

```
系统级安全目标（ASIL-D）
    │
    ├─ 路径 A：主计算链路（ASIL-B）
    │    CPU + GPU/NPU，软件冗余
    │
    └─ 路径 B：安全监控链路（ASIL-B）
         独立 MCU，硬件看门狗，ASIL-D 认证

ASIL-B(D) = ASIL-B × 2 = 可等效达到 ASIL-D
```

### 4.2 安全机制覆盖率要求

| 故障类型 | 要求的诊断覆盖率 | 典型机制 |
| --- | --- | --- |
| CPU 计算错误 | > 90%（ASIL-D）| 锁步核、CRC 校验 |
| 内存位翻转 | > 99%（ASIL-D）| ECC（SECDED）|
| 时序违规（超时）| > 95% | 硬件看门狗 |
| 软件错误（逻辑故障）| > 60% | 端到端 E2E 校验 |
| 通信错误 | > 97% | CRC + 计数器 + 超时 |

### 4.3 FMEA 分析流程

功能安全分析（FMEA/FTA）需要覆盖：

1. **危害分析与风险评估（HARA）**：识别危险事件，确定 ASIL 等级
2. **功能安全概念**：定义安全目标（Safety Goal）
3. **技术安全概念**：分配安全机制到硬件/软件
4. **安全分析**（FTA/FMEA）：验证安全目标可达性

---

## 5. 硬件安全机制详解

### 5.1 ECC 内存

ECC（Error Correction Code）用于检测和纠正内存位翻转：

- **SECDED（Single Error Correct, Double Error Detect）**：可纠正 1 位错误，检测 2 位错误
- **开销**：每 64 位数据需要额外 8 位校验位（约 12.5% 存储开销）
- **影响**：ECC 读写引入约 1–5% 的性能损耗

```
ECC 工作流程：
写入：数据 + 计算 Parity → 写入内存（数据+校验码）
读取：读取数据+校验码 → 重新计算 Parity → 比较 → 无误/纠正/报错
```

### 5.2 锁步核（Lockstep Core）

两个 CPU 核执行完全相同的指令序列，每个时钟周期比较输出：

```
输入指令 ─→ Core A ─→ 输出 A ─┐
             └──────────────→  比较器 ─→ 一致：正常
输入指令 ─→ Core B ─→ 输出 B ─┘         不一致：触发故障
```

- 检测覆盖率：> 99%（随机硬件故障）
- 代价：算力减半（两个核做同一件事）
- 适用：安全岛 MCU，不适合高算力计算

### 5.3 独立安全岛（Safety Island）

```
主 SoC（CPU + GPU/NPU）
    │ 心跳/状态上报
    ↓
安全岛 MCU（独立电源，ASIL-D 认证）
    │ 监控主 SoC 运行状态
    ├─ 心跳超时 → 触发主 SoC 复位
    ├─ 输出异常 → 触发 TOR / MRC
    └─ 自身故障 → 安全输出（使能制动保持）
```

安全岛与主 SoC 电源域完全独立，确保主 SoC 故障时仍能执行最小风险动作。

---

## 6. 网络安全能力

### 6.1 硬件安全模块（HSM）

HSM 是独立的安全协处理器，提供可信执行环境：

```
HSM 功能：
  ├─ 安全密钥存储（不可导出）
  ├─ 硬件加密加速（AES/ECC/RSA）
  ├─ 真随机数生成器（TRNG）
  ├─ 单调计数器（防重放攻击）
  └─ 安全存储（防篡改 OTP/Flash）
```

### 6.2 安全启动链

```
Boot ROM（片上只读，芯片出厂固化）
    │ 验证 Bootloader 数字签名（设备证书）
    ↓
Bootloader（已验证）
    │ 验证 OS 镜像签名
    ↓
操作系统（已验证）
    │ 验证应用程序签名
    ↓
运行时应用（可信执行）
```

每一级使用 ECDSA-P256 或 RSA-2048 签名验证，公钥存储在 HSM 不可篡改区域。

### 6.3 OTA 安全

```
OTA 更新包安全保障：
  ├─ 厂商私钥签名（车端公钥验证）
  ├─ SHA-256 哈希完整性校验
  ├─ 版本回滚保护（单调计数器）
  └─ A/B 分区切换 + 健康检查 + 自动回滚
```

---

## 7. 车规级验证测试

### 7.1 AEC-Q100 可靠性测试

| 测试类别 | 测试条件 | 标准 |
| --- | --- | --- |
| 温度循环 | -40°C ↔ 125°C，1000 次循环 | AEC-Q100 Grade 2 |
| 高温工作寿命 | 150°C，1000 小时 | HTOL |
| 电源瞬变 | 电压跌落/尖峰测试 | ISO 7637 |
| EMC 辐射 | 30 MHz–1 GHz 辐射发射 | CISPR 25 |
| ESD | ±2 kV（人体模型）| AEC-Q100-002 |
| 振动/冲击 | 20 Hz–2000 Hz，20 g | ISO 16750-3 |

### 7.2 工作温度范围

| 等级 | 温度范围 | 适用场景 |
| --- | --- | --- |
| Grade 0 | -40°C ～ +150°C | 引擎舱 |
| Grade 1 | -40°C ～ +125°C | 底盘/传动 |
| Grade 2 | -40°C ～ +105°C | 车身控制 |
| Grade 3 | -40°C ～ +85°C | 座舱/驾驶辅助 |

---

## 8. 故障注入测试

| 测试场景 | 注入方式 | 期望结果 |
| --- | --- | --- |
| 内存位翻转 | 软件注入单/双位错误 | ECC 纠正/上报，无数据损坏 |
| CPU 锁步不一致 | 在一个核注入错误计算 | 硬件立即检测，触发安全复位 |
| 看门狗超时 | 主进程挂起不喂狗 | 60 ms 内 MCU 触发复位或降级 |
| 网络丢包 | 丢弃关键 CAN 帧 | 触发超时检测，输出安全值 |
| 电源欠压 | 电源降至欠压阈值 | 触发保护，不产生危险输出 |
| 温度超限 | 注入过温告警 | 频率降级，上报故障码 |

**测试通过标准：**

- 无未检测到的危险故障（Safety Goal 不被违背）
- 故障检测时间 < 规定的 FTTI（Fault Tolerant Time Interval）
- 降级行为符合安全状态规范

---

## 9. 验证建议

1. **建立长稳测试基线**：至少 7 天 × 24 小时全负载连续运行，记录重启次数、ECC 错误率、热降频频次
2. **故障注入自动化**：将故障注入脚本纳入 CI/CD 流水线，每次 MCU 固件或主 SoC 软件更新后自动执行
3. **量化关键指标**：时延 P99、掉帧率、故障检测时间（FTTI 验证）、恢复时间（MTTR）
4. **跨版本兼容验证**：每次 OTA 升级后验证功能安全机制仍正常工作
